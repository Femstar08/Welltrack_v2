import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:welltrack/features/health/domain/health_metric_entity.dart';

/// Supabase implementation of health metrics storage
/// Handles bulk inserts, deduplication, and retrieval of health metrics
class HealthRepositoryImpl {
  final SupabaseClient _supabase;

  HealthRepositoryImpl({
    SupabaseClient? supabase,
  }) : _supabase = supabase ?? Supabase.instance.client;

  /// Saves health metrics in bulk to Supabase
  /// Uses ON CONFLICT dedupe_hash to prevent duplicates (auto-generated by DB trigger)
  /// Returns count of successfully inserted records
  Future<int> saveHealthMetrics(List<HealthMetricEntity> metrics) async {
    if (metrics.isEmpty) return 0;

    try {
      // Convert metrics to Supabase JSON format
      final jsonMetrics = metrics.map((m) => m.toSupabaseJson()).toList();

      // Bulk insert with conflict handling on dedupe_hash
      // The DB trigger auto-generates dedupe_hash if not provided
      await _supabase.from('wt_health_metrics').upsert(
            jsonMetrics,
            onConflict: 'dedupe_hash',
          );

      // Return count of metrics processed
      return metrics.length;
    } catch (e) {
      print('Error saving health metrics: $e');
      rethrow;
    }
  }

  /// Gets the most recent sync time for a specific user and metric type
  /// Returns null if no records exist
  Future<DateTime?> getLastSyncTime(String userId, String metricType) async {
    try {
      final response = await _supabase
          .from('wt_health_metrics')
          .select('recorded_at')
          .eq('user_id', userId)
          .eq('metric_type', metricType)
          .order('recorded_at', ascending: false)
          .limit(1)
          .maybeSingle();

      if (response == null) return null;

      return DateTime.parse(response['recorded_at'] as String);
    } catch (e) {
      print('Error getting last sync time: $e');
      return null;
    }
  }

  /// Performs deduplication cleanup for any duplicate metrics that slipped through
  /// Keeps the most detailed record per dedupe_hash
  /// This is a safety net; the DB trigger should handle most cases
  Future<void> deduplicateMetrics(String userId, String profileId) async {
    try {
      // Find duplicates by grouping on key fields
      // Since dedupe_hash is UNIQUE, we shouldn't have duplicates at the DB level
      // This method can be used to clean up any edge cases or manual data issues

      // Query to find potential duplicates based on same user, profile, source, type, and time
      final response = await _supabase.rpc(
        'deduplicate_health_metrics',
        params: {
          'p_user_id': userId,
          'p_profile_id': profileId,
        },
      );

      print('Deduplication completed: $response');
    } catch (e) {
      // If the stored procedure doesn't exist, we skip deduplication
      // The DB trigger handles most cases
      print('Deduplication skipped or failed: $e');
    }
  }

  /// Fetches health metrics since a specific date for given metric types
  /// Used by dashboard and insights to show recent health data
  /// Returns metrics ordered by start_time descending (newest first)
  Future<List<HealthMetricEntity>> getMetricsSince(
    String userId,
    DateTime since,
    List<String> types,
  ) async {
    try {
      if (types.isEmpty) return [];

      var query = _supabase
          .from('wt_health_metrics')
          .select()
          .eq('user_id', userId)
          .gte('start_time', since.toIso8601String())
          .inFilter('metric_type', types)
          .order('start_time', ascending: false);

      final response = await query;

      return (response as List)
          .map((json) => HealthMetricEntity.fromSupabaseJson(json))
          .toList();
    } catch (e) {
      print('Error fetching metrics since $since: $e');
      return [];
    }
  }

  /// Fetches health metrics for a specific date range and profile
  /// Optionally filters by metric type
  /// Used by baseline calibration and detailed metric views
  Future<List<HealthMetricEntity>> getMetricsForDateRange(
    String profileId,
    DateTime start,
    DateTime end, {
    String? metricType,
  }) async {
    try {
      var query = _supabase
          .from('wt_health_metrics')
          .select()
          .eq('profile_id', profileId)
          .gte('start_time', start.toIso8601String())
          .lte('start_time', end.toIso8601String());

      if (metricType != null) {
        query = query.eq('metric_type', metricType);
      }

      final response = await query.order('start_time', ascending: true);

      return (response as List)
          .map((json) => HealthMetricEntity.fromSupabaseJson(json))
          .toList();
    } catch (e) {
      print('Error fetching metrics for date range: $e');
      return [];
    }
  }

  /// Gets metrics by metric type enum for a profile and date range
  /// Helper method that uses MetricType enum instead of string
  Future<List<HealthMetricEntity>> getMetricsByType(
    String profileId,
    MetricType metricType, {
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      var query = _supabase
          .from('wt_health_metrics')
          .select()
          .eq('profile_id', profileId)
          .eq('metric_type', metricType.name)
          .eq('validation_status', ValidationStatus.validated.name);

      if (startDate != null) {
        query = query.gte('start_time', startDate.toIso8601String());
      }

      if (endDate != null) {
        query = query.lte('start_time', endDate.toIso8601String());
      }

      final response = await query.order('start_time', ascending: false);

      return (response as List)
          .map((json) => HealthMetricEntity.fromSupabaseJson(json))
          .toList();
    } catch (e) {
      print('Error fetching metrics by type: $e');
      return [];
    }
  }

  /// Gets count of validated metrics for a profile and metric type
  /// Used to check baseline calibration requirements
  Future<int> getMetricCount(
    String profileId,
    MetricType metricType, {
    DateTime? since,
  }) async {
    try {
      var query = _supabase
          .from('wt_health_metrics')
          .select('id')
          .eq('profile_id', profileId)
          .eq('metric_type', metricType.name)
          .eq('validation_status', ValidationStatus.validated.name);

      if (since != null) {
        query = query.gte('start_time', since.toIso8601String());
      }

      final response = await query;
      return (response as List).length;
    } catch (e) {
      print('Error getting metric count: $e');
      return 0;
    }
  }

  /// Gets the first and last data point timestamps for a metric type
  /// Returns null if no data exists
  Future<({DateTime? first, DateTime? last})?> getDataTimeRange(
    String profileId,
    MetricType metricType,
  ) async {
    try {
      final firstQuery = await _supabase
          .from('wt_health_metrics')
          .select('start_time')
          .eq('profile_id', profileId)
          .eq('metric_type', metricType.name)
          .eq('validation_status', ValidationStatus.validated.name)
          .order('start_time', ascending: true)
          .limit(1)
          .maybeSingle();

      final lastQuery = await _supabase
          .from('wt_health_metrics')
          .select('start_time')
          .eq('profile_id', profileId)
          .eq('metric_type', metricType.name)
          .eq('validation_status', ValidationStatus.validated.name)
          .order('start_time', ascending: false)
          .limit(1)
          .maybeSingle();

      if (firstQuery == null || lastQuery == null) return null;

      return (
        first: DateTime.parse(firstQuery['start_time'] as String),
        last: DateTime.parse(lastQuery['start_time'] as String),
      );
    } catch (e) {
      print('Error getting data time range: $e');
      return null;
    }
  }

  /// Gets stress metrics for a specific date range
  /// Garmin Stress Score is 0-100, stored as-is
  Future<List<HealthMetricEntity>> getStressMetrics(
    String profileId,
    DateTime start,
    DateTime end,
  ) async {
    return getMetricsForDateRange(
      profileId,
      start,
      end,
      metricType: MetricType.stress.name,
    );
  }

  /// Gets sleep metrics for a specific date range
  /// Returns all sleep sessions with duration in minutes
  Future<List<HealthMetricEntity>> getSleepMetrics(
    String profileId,
    DateTime start,
    DateTime end,
  ) async {
    return getMetricsForDateRange(
      profileId,
      start,
      end,
      metricType: MetricType.sleep.name,
    );
  }

  /// Gets VO2 max metrics for a specific date range
  /// Primary sources: Garmin, Strava; optional: Health Connect/HealthKit
  Future<List<HealthMetricEntity>> getVO2MaxMetrics(
    String profileId,
    DateTime start,
    DateTime end,
  ) async {
    return getMetricsForDateRange(
      profileId,
      start,
      end,
      metricType: MetricType.vo2max.name,
    );
  }

  /// Gets average value for a metric type over a date range
  /// Returns null if no data exists
  Future<double?> getAverageMetricValue(
    String profileId,
    MetricType metricType,
    DateTime start,
    DateTime end,
  ) async {
    try {
      final metrics = await getMetricsForDateRange(
        profileId,
        start,
        end,
        metricType: metricType.name,
      );

      if (metrics.isEmpty) return null;

      final values = metrics
          .where((m) => m.valueNum != null)
          .map((m) => m.valueNum!)
          .toList();

      if (values.isEmpty) return null;

      return values.reduce((a, b) => a + b) / values.length;
    } catch (e) {
      print('Error calculating average metric value: $e');
      return null;
    }
  }

  /// Gets median value for a metric type over a date range
  /// Returns null if no data exists
  Future<double?> getMedianMetricValue(
    String profileId,
    MetricType metricType,
    DateTime start,
    DateTime end,
  ) async {
    try {
      final metrics = await getMetricsForDateRange(
        profileId,
        start,
        end,
        metricType: metricType.name,
      );

      if (metrics.isEmpty) return null;

      final values = metrics
          .where((m) => m.valueNum != null)
          .map((m) => m.valueNum!)
          .toList();

      if (values.isEmpty) return null;

      values.sort();
      final middle = values.length ~/ 2;

      if (values.length % 2 == 1) {
        return values[middle];
      } else {
        return (values[middle - 1] + values[middle]) / 2;
      }
    } catch (e) {
      print('Error calculating median metric value: $e');
      return null;
    }
  }

  /// Deletes metrics for a specific profile
  /// Used when profile is deleted or for data cleanup
  /// Returns count of deleted records
  Future<int> deleteMetricsForProfile(String profileId) async {
    try {
      // Fetch IDs first, then delete
      final existing = await _supabase
          .from('wt_health_metrics')
          .select('id')
          .eq('profile_id', profileId);

      final count = (existing as List).length;

      if (count > 0) {
        await _supabase
            .from('wt_health_metrics')
            .delete()
            .eq('profile_id', profileId);
      }

      return count;
    } catch (e) {
      print('Error deleting metrics for profile: $e');
      return 0;
    }
  }

  /// Updates processing status for metrics
  /// Used after validation or processing steps
  Future<void> updateProcessingStatus(
    List<String> metricIds,
    ProcessingStatus status,
  ) async {
    try {
      await _supabase.from('wt_health_metrics').update({
        'processing_status': status.name,
        'updated_at': DateTime.now().toIso8601String(),
      }).inFilter('id', metricIds);
    } catch (e) {
      print('Error updating processing status: $e');
      rethrow;
    }
  }

  /// Updates validation status for metrics
  /// Used after validation logic runs
  Future<void> updateValidationStatus(
    List<String> metricIds,
    ValidationStatus status,
  ) async {
    try {
      await _supabase.from('wt_health_metrics').update({
        'validation_status': status.name,
        'updated_at': DateTime.now().toIso8601String(),
      }).inFilter('id', metricIds);
    } catch (e) {
      print('Error updating validation status: $e');
      rethrow;
    }
  }
}

/// Riverpod provider for HealthRepositoryImpl
final healthRepositoryImplProvider = Provider<HealthRepositoryImpl>((ref) {
  return HealthRepositoryImpl();
});
